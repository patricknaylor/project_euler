#########################################
#
# Project Euler Problem 12
#
# The sequence of triangle numbers is generated by adding the natural numbers.
# So, the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
# The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55
# What is the value of the first triangle number to have over five hundred divisors?
#
#########################################

# triangle numbers have the form n*(n+1)/2
# we will ultimately have to factor each number of this form
# as usual, we will use a sieve to find all the primes less than some bound--
# unfortunately, we don't know how many primes we'll actually need--
# it's entirely possible that our triangular numbers will have large prime factors.

# uses a sieve to get a list of primes less than some bound
def get_primes(bound):
    primes = [True for _ in range(bound)]
    primes[0], primes[1] = False, False

    p = 2

    while p * p < bound:

        # given a prime number p
        if primes[p]:

            # all multiples of p aren't prime!
            for n in range(p * p, bound, p):
                primes[n] = False

        # lastly, increment the number
        p += 1

    return primes


# if we find all the primes less than 1000000, we can factor anything up to ~14 digits
is_prime = get_primes(1000000)
primes_list = [p for p in range(1000000) if is_prime[p]]

# although we don't know if we've built enough primes, this factoring function will print an error
# if it discovers we might be out of range


# given a number, this returns the prime factorization
def factor(number):

    if number > primes_list[-1]**2:
        raise "Factoring might fail somewhere!"

    n = number
    factor_list = []
    while n > 1:
        for prime in primes_list:
            if n % prime == 0:
                factor_list.append(prime)
                n = int(n / prime)
        
    return factor_list


# given a prime factorization, the number of factors is easy to compute--
# it's the product of the count (+1) of each prime factor
def number_of_factors(number):
    factorization = factor(number)
    distinct = set(factorization)

    count = [factorization.count(n) + 1 for n in distinct]

    def prod(lst):
        total = 1
        for i in lst:
            total *= i
        return total

    product = prod(count)

    return product


# now, we can search for our triangular number.
# this returns the first triangle with more than a set number of factors--
# it will run forever (until the factorization function throws an error)
def search_for_triangle(factors):

    n = 1

    while True:
        triangle = int(n*(n+1)/2)
        if number_of_factors(triangle) > factors:
            return triangle
        n += 1


print("The first triangular number with more than {} factors is {}.".format(500, search_for_triangle(500)))
