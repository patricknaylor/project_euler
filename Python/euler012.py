#########################################
#
#Project Euler Problem 12
#
#The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
#The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55
#What is the value of the first triangle number to have over five hundred divisors?
#########################################

from math import prod #to multiply elements of a list together

#the triangle numbers have the form n*(n+1)/2
#we will ultimately have to factor each number of this form
#as usual, we will use a sieve to find all the primes less than some bound--
#unfortunately, we don't know how many primes we'll actually need-- it's entirely possible that our triangular numbers will
#have large prime factors.

#import math has lots of functions, but this will be fun to do from scratch

#if we take bound = 100000, we can fatctor anything up to ~12 digits
bound = 100000
sqrtbound = int(bound**0.5)

#returns a list of primes less than some bound
def get_primes(bound):
    integers = [i for i in range(bound)]

    for i in range (2,sqrtbound+1):
        for j in range(i+1,bound):
            if j%i == 0:
                integers[j] = 0

    primes = [item for item in integers if item != 0 and item !=1]
    return primes

primes = get_primes(bound)
print("Found {} prime numbers, the largest of which is {}.".format(len(primes), primes[-1]))


#although we don't know if we've built enough primes, this factoring function will print an error
#if it discovers we even -might- be out of range
#this way, we can adjust the bound as need be

#given a number, this returns the prime factorization 
def factor(number):
    if number > primes[-1]**2:
        print("Factoring might fail somewhere")
    n = number
    factor_list=[]
    while n > 1:
        for prime in primes:
            if n%prime == 0:
                factor_list.append(prime)
                n=int(n/prime)
        
    return factor_list

#given a prime factorization, the number of factors is easy to compute
def number_of_factors(number):
    factorization = factor(number)
    distinct = set(factorization)

    count = [factorization.count(n)+1 for n in distinct]
    product = prod(count)

    return product

#now, we can search for our triangular number.
#this returns the first triangle with more than number_of_factors factors
def search_for_triangle(factors):
    
    found = False
    n = 1

    while not found:
        triangle = int(n*(n+1)/2)
        if number_of_factors(triangle) > factors:
            return triangle
            found = True
        n += 1

factors = 500
print("The first triangular number with more than {} factors is {}.".format(factors, search_for_triangle(factors)))

#The answer is 76576500

